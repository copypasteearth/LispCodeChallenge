(defun sub-lists(l m &optional(x 0)(y 0))
  (cond; ((and(= y (length l))(= x (length l)))nil)
        ((= y (length l))m)
        ((= x (length l))(sub-lists l m 0(1+ y)))
	(t (sub-lists l (cons(loop for a from x to (+ x y)
        
		     when (and(nth (+ x y)l)(nth a l)(< (+ x y)(length l)))
				;	while (nth a l)
		     ;while(and(< (+ x y)(length l))(nth a l))
				    collect (nth a l))m) (1+ x)y))
	))
(defun num-permutations (list)
  (cond ((null list) nil)
        ((null (cdr list)) (list list))
        (t (loop for element in list
             append (mapcar (lambda (l) (cons element l))
                            (num-permutations (remove element list)))))))
(defun permutations(size elements)
  (if (zerop size)'(())
 (mapcan (lambda (p)
                    (map 'list (lambda (e)
                           (cons e p))
                         elements))
	 (permutations (1- size) elements))))
(defun remove-reverse(l m)
  (cond ((endp l)m)
	((member (reverse (first l))(rest l) :test #'equal)(remove-reverse (rest l)m))
	(t (remove-reverse (rest l)(cons (first l)m)))))
;;;(defun main(n s)
;;;  (let((l (remove-reverse (permutations n `(,s ,(1+ s)))nil)))
 
;;;  (loop for x in l
;;;     for j = (remove 'nil (sub-lists x nil))
;;;       collect(sort (make-set(loop for y in j
;;;	    collect (apply '+ y))nil)#'<)
 ;;;    )
;;;  ))
(defun main(n s)
  (let ((l (remove-reverse (permutations n `(,s ,(1+ s)))nil)))
    (mapcar (lambda(x)
	      (let((h (remove 'nil (sub-lists x nil))))
		(sort (make-set(mapcar (lambda(y)
			  (apply '+ y))h)nil)#'<)))l)))
(defun remove-dups(l m n)
  (cond ((endp l)n)
        ((member (first l) (rest l) :test #'equal)(remove-dups(rest l)(cons (first l) m) n))
	((member (first l) m :test #'equal)(remove-dups(rest l)m n))
	(t(remove-dups (rest l) m (cons (first l) n))))
	
  )
(defun goahead(n s)
  (loop for a from 1 to s
  collect(length (remove-dups(main n a)nil nil))))
(defun make-set (L m)
  "Returns a set from a list. Duplicate elements are removed."
  (cond ((endp L) m)
	((member (first L) (rest L)) (make-set (rest L)m))
	( t (make-set (rest L)(cons (first l)m)))))

